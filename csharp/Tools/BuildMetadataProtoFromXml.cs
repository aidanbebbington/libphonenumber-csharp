/*
 * Copyright (C) 2009 The Libphonenumber Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Reflection;
using System.Text;
using System.Text.RegularExpressions;
using PhoneNumbers;

namespace Tools
{



    /**
     * Tool to convert phone number metadata from the XML format to protocol buffer format.
     *
     * <p>
     * Based on the name of the {@code inputFile}, some optimization and removal of unnecessary metadata
     * is carried out to reduce the size of the output file.
     *
     * @author Shaopeng Jia
     */
    public class BuildMetadataProtoFromXml : Command
    {
        private static readonly string ClassName = Assembly.GetExecutingAssembly().FullName;
        private static readonly string PackageName = Assembly.GetExecutingAssembly().Location;

        // Command line parameter names.
        private const string INPUT_FILE = "input-file";
        private const string OUTPUT_DIR = "output-dir";
        private const string DATA_PREFIX = "data-prefix";
        private const string MAPPING_CLASS = "mapping-class";
        private const string COPYRIGHT = "copyright";
        private const string SINGLE_FILE = "single-file";

        private const string LITE_BUILD = "lite-build";

        // Only supported for clients who have consulted with the libphonenumber team, and the behavior is
        // subject to change without notice.
        private const string SPECIAL_BUILD = "special-build";

        private static readonly string HelpMessage =
            "Usage: " + ClassName + " [OPTION]...\n" +
            "\n" +
            "  --" + INPUT_FILE + "=PATH     Read phone number metadata in XML format from PATH.\n" +
            "  --" + OUTPUT_DIR + "=PATH     Use PATH as the root directory for output files.\n" +
            "  --" + DATA_PREFIX +
            "=PATH    Use PATH (relative to " + OUTPUT_DIR + ") as the basename when\n" +
            "                        writing phone number metadata in proto format.\n" +
            "                        One file per region will be written unless " + SINGLE_FILE + "\n" +
            "                        is set, in which case a single file will be written with\n" +
            "                        metadata for all regions.\n" +
            "  --" + MAPPING_CLASS + "=NAME  Store country code mappings in the class NAME, which\n" +
            "                        will be written to a file in " + OUTPUT_DIR + ".\n" +
            "  --" + COPYRIGHT + "=YEAR      Use YEAR in generated copyright headers.\n" +
            "\n" +
            "  [--" + SINGLE_FILE + "=<true|false>] Optional (default: false). Whether to write\n" +
            "                               metadata to a single file, instead of one file\n" +
            "                               per region.\n" +
            "  [--" + LITE_BUILD + "=<true|false>]  Optional (default: false). In a lite build,\n" +
            "                               certain metadata will be omitted. At this\n" +
            "                               moment, example numbers information is omitted.\n" +
            "\n" +
            "Example command line invocation:\n" +
            ClassName + " \\\n" +
            "  --" + INPUT_FILE + "=resources/PhoneNumberMetadata.xml \\\n" +
            "  --" + OUTPUT_DIR + "=java/libphonenumber/src/com/google/i18n/phonenumbers \\\n" +
            "  --" + DATA_PREFIX + "=data/PhoneNumberMetadataProto \\\n" +
            "  --" + MAPPING_CLASS + "=CountryCodeToRegionCodeMap \\\n" +
            "  --" + COPYRIGHT + "=2010 \\\n" +
            "  --" + SINGLE_FILE + "=false \\\n" +
            "  --" + LITE_BUILD + "=false\n";

        private static readonly string GenerationComment =
            "/* This file is automatically generated by {@link " + ClassName + "}.\n" +
            " * Please don't modify it directly.\n" +
            " */\n\n";

        public override string getCommandName()
        {
            return ClassName;
        }

        public override bool start()
        {
            // The format of a well-formed command line parameter.
            Regex pattern = new Regex("--(.+?)=(.*)");

            string inputFile = null;
            string outputDir = null;
            string dataPrefix = null;
            string mappingClass = null;
            string copyright = null;
            bool singleFile = false;
            bool liteBuild = false;
            bool specialBuild = false;

            for (int i = 1; i < getArgs().Length; i++)
            {
                string key = null;
                string value = null;
                var matcher = pattern.Match(getArgs()[i]);
                if (matcher.Success)
                {
                    key = matcher.Groups[0].Value;
                    value = matcher.Groups[1].Value;
                }

                if (INPUT_FILE.Equals(key))
                {
                    inputFile = value;
                }
                else if (OUTPUT_DIR.Equals(key))
                {
                    outputDir = value;
                }
                else if (DATA_PREFIX.Equals(key))
                {
                    dataPrefix = value;
                }
                else if (MAPPING_CLASS.Equals(key))
                {
                    mappingClass = value;
                }
                else if (COPYRIGHT.Equals(key))
                {
                    copyright = value;
                }
                else if (SINGLE_FILE.Equals(key) &&
                         ("true".Equals(value.ToLower()) || "false".Equals(value.ToLower())))
                {
                    singleFile = "true".Equals(value.ToLower());
                }
                else if (LITE_BUILD.Equals(key) &&
                         ("true".Equals(value.ToLower()) || "false".Equals(value.ToLower())))
                {
                    liteBuild = "true".Equals(value.ToLower());
                }
                else if (SPECIAL_BUILD.Equals(key) &&
                         ("true".Equals(value.ToLower()) || "false".Equals(value.ToLower())))
                {
                    specialBuild = "true".Equals(value.ToLower());
                }
                else
                {
                    Console.WriteLine(HelpMessage);
                    Console.WriteLine("Illegal command line parameter: " + getArgs()[i]);
                    return false;
                }
            }

            if (inputFile == null ||
                outputDir == null ||
                dataPrefix == null ||
                mappingClass == null ||
                copyright == null)
            {
                Console.WriteLine(HelpMessage);
                return false;
            }

            string filePrefix = "prefix"; // todo get real prefix

            try
            {
                PhoneMetadataCollection metadataCollection =
                    BuildMetadataFromXml.BuildPhoneMetadataCollection(new FileStream(inputFile, FileMode.Open), liteBuild, specialBuild);

                if (singleFile)
                {
                    StreamWriter output = new StreamWriter(filePrefix);
                    metadataCollection.ReadExternal(output);
                    output.Close();
                }
                else
                {
                    foreach (PhoneMetadata metadata in
                    metadataCollection.MetadataList)
                    {
                        string regionCode = metadata.Id;
                        // For non-geographical country calling codes (e.g. +800), or for alternate formats, use the
                        // country calling codes instead of the region code to form the file name.
                        if (regionCode.Equals("001") || !regionCode.Any())
                        {
                            regionCode = metadata.CountryCode.ToString();
                        }

                        PhoneMetadataCollection.Builder outMetadataCollection = new PhoneMetadataCollection.Builder();
                        outMetadataCollection.AddMetadata(metadata);
                        FileStream outputForRegion = new FileStream(filePrefix + "_" + regionCode, FileMode.CreateNew);
                        BinaryWriter output = new BinaryWriter(outputForRegion);
                        outMetadataCollection.WriteExternal(output);
                            output.Close();
                    }
                }

                Dictionary<int, List<string>> countryCodeToRegionCodeMap =
                    BuildMetadataFromXml.BuildCountryCodeToRegionCodeMap(metadataCollection);

                WriteCountryCallingCodeMappingToJavaFile(
                    countryCodeToRegionCodeMap, outputDir, mappingClass, copyright);
            }
            catch (Exception e)
            {
                Console.WriteLine(e.StackTrace);
                return false;
            }

            Console.WriteLine("Metadata code successfully generated.");
            return true;
        }

        private const string MAP_COMMENT =
            "  // A mapping from a country code to the region codes which denote the\n" +
            "  // country/region represented by that country code. In the case of multiple\n" +
            "  // countries sharing a calling code, such as the NANPA countries, the one\n" +
            "  // indicated with \"isMainCountryForCode\" in the metadata should be first.\n";

        private const string COUNTRY_CODE_SET_COMMENT =
            "  // A set of all country codes for which data is available.\n";

        private const string REGION_CODE_SET_COMMENT =
            "  // A set of all region codes for which data is available.\n";

        private static readonly double CapacityFactor = 0.75;

        private static readonly string CapacityComment =
            "    // The capacity is set to {0} as there are {1} different entries,\n" +
            "    // and this offers a load factor of roughly " + CapacityFactor + ".\n";

        private static void WriteCountryCallingCodeMappingToJavaFile(
            Dictionary<int, List<string>> countryCodeToRegionCodeMap,
            string outputDir, string mappingClass, string copyright)
        {
            // Find out whether the countryCodeToRegionCodeMap has any region codes or country
            // calling codes listed in it.
            bool hasRegionCodes = false;
            foreach (List<string> listWithRegionCode in countryCodeToRegionCodeMap.Values)
            {
                if (listWithRegionCode.Any())
                {
                    hasRegionCodes = true;
                    break;
                }
            }

            bool hasCountryCodes = countryCodeToRegionCodeMap.Count > 1;

            ClassWriter writer = new ClassWriter(outputDir, mappingClass, copyright);

            int capacity = (int) (countryCodeToRegionCodeMap.Count / CapacityFactor);
            if (hasRegionCodes && hasCountryCodes)
            {
                WriteMap(writer, capacity, countryCodeToRegionCodeMap);
            }
            else if (hasCountryCodes)
            {
                WriteCountryCodeSet(writer, capacity, countryCodeToRegionCodeMap.Keys.ToHashSet());
            }
            else
            {
                List<string> regionCodeList = countryCodeToRegionCodeMap[0];
                capacity = (int) (regionCodeList.Count / CapacityFactor);
                WriteRegionCodeSet(writer, capacity, regionCodeList);
            }

            writer.WriteToFile();
        }

        private static void WriteMap(ClassWriter writer, int capacity,
            Dictionary<int, List<string>> countryCodeToRegionCodeMap)
        {
            writer.AddToBody(MAP_COMMENT);

            writer.AddToUsings("System.Collections.Generic");

            writer.AddToBody("  static Dictionary<int, List<string>> getCountryCodeToRegionCodeMap()\r\n  {\r\n");
            writer.AddToBody(CapacityComment, capacity, countryCodeToRegionCodeMap.Count);
            writer.AddToBody("    return new Dictionary<int, List<string>>(" + capacity + ")\r\n");
            writer.AddToBody("    {\r\n");

            foreach (var entry in countryCodeToRegionCodeMap)
            {
                writer.AddToBody($"      {{ {entry.Key}, new List<string> {{ ");
                writer.AddToBody("" + string.Join(", ", entry.Value));
                writer.AddToBody(" } },\r\n");
            }

            writer.Backspace();
            writer.AddToBody("\r\n    };\r\n");
            writer.AddToBody("  }\r\n");
        }

        private static void WriteRegionCodeSet(ClassWriter writer, int capacity,
            List<string> regionCodeList)
        {
            writer.AddToBody(REGION_CODE_SET_COMMENT);

            writer.AddToUsings("System.Collections.Generic");

            writer.AddToBody("  static HashSet<string> getRegionCodeSet()\r\n  {\r\n");
            writer.AddToBody(CapacityComment, capacity, regionCodeList.Count);
            writer.AddToBody("    return new HashSet<string>");
            writer.AddToBody("      " + string.Join(",\r\n      ", regionCodeList));
            writer.AddToBody("    };\r\n");
            writer.AddToBody("  }");
        }

        private static void WriteCountryCodeSet(ClassWriter writer, int capacity,
            HashSet<int> countryCodeSet)
        {
            writer.AddToBody(COUNTRY_CODE_SET_COMMENT);

            writer.AddToUsings("System.Collections.Generic");

            writer.AddToBody("  static HashSet<int> GetCountryCodeSet()\r\n  {\r\n");
            writer.AddToBody(CapacityComment, capacity, countryCodeSet.Count);
            writer.AddToBody("    return new HashSet<int>\r\n    { ");

            writer.AddToBody("      " + string.Join(",\r\n      ", countryCodeSet));

            writer.AddToBody("    };\r\n");
            writer.AddToBody("  }\r\n");
        }

        internal class ClassWriter
        {
            private readonly string name;
            private readonly string copyright;

            private readonly SortedSet<string> usings;
            private readonly StringBuilder body;
            private readonly StreamWriter writer;

            internal ClassWriter(string outputDir, string name, string copyright)
            {
                this.name = name;
                this.copyright = copyright;

                usings = new SortedSet<string>();
                body = new StringBuilder();
                writer = new StreamWriter(new FileStream(outputDir + name + ".cs", FileMode.CreateNew));
            }

            internal void AddToUsings(string import)
            {
                usings.Add(import);
            }

            internal void AddToBody(string text, params object[] args)
            {
                body.Append(string.Format(text, args));
            }

            internal void Backspace()
            {
                body.Length--;
            }

            internal void WriteToFile()
            {
                CopyrightNotice.WriteTo(writer, copyright.Length);
                writer.Write(GenerationComment);
                writer.Write("namespace " + PackageName + "\r\n{\r\n");

                if (usings.Any())
                {
                    foreach (var item in usings)
                    {
                        writer.Write("using " + item + ";\r\n");
                    }

                    writer.Write("\r\n");
                }

                writer.Write("  public class " + name + "\r\n    {\r\n");
                writer.Write(body.ToString());
                writer.Write("  }\r\n\r\n}\r\n");

                writer.Flush();
                writer.Close();
            }
        }
    }
}
